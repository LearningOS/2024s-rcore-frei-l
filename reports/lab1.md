# 代码说明

实现的功能主要分为两部分，一个是系统调用的计数，另一个是计时。都是通过在TCB的结构体中新增字段实现的。

- **数据传递**：信息是存储在TCB中，而TCB在内核空间中，所以这里涉及需要把内核空间的数据拷贝到用户空间。

- **系统调用计数**：练习说明已经明确了桶排序，在TCB中开一个数组，每次系统调用在match之前，都把sysycall id作为参数给task manager, 为当前的进程增加对应的系统调用的计数。

- **系统调用计时**：计时主要注意单位换算，是微秒，就没有太大问题。其次是任务启动有两种可能，一种是作为第一个任务被启动，第二种是作为就绪任务在切换进程时被调度。考虑两种情况，在tcb中记录当前时间。这里使用的option类型，尚未被调度的进程字段值为none.

# 简答作业

## bad 测例

第一个进程因为段错误被killed了，另外两个因为非法指令也被killed了

```shell	
[kernel] Loading app_0
[kernel] PageFault in application, kernel killed it.
[kernel] Loading app_1
[kernel] IllegalInstruction in application, kernel killed it.
[kernel] Loading app_2
[kernel] IllegalInstruction in application, kernel killed it.
```

```shell
[rustsbi] RustSBI version 0.3.0-alpha.4, adapting to RISC-V SBI v1.0.0
```

## 深入理解trap.S

### L40：刚进入 `__restore` 时，`a0` 代表了什么值。请指出 `__restore` 的两种使用情景。

寄存器 a0 指向内核栈的栈指针也就是刚刚保存的 Trap 上下文的地址

__restore 的两种使用情景

- 处理完成中断或trap后，从S态恢复到U态
- 启动一个应用。构造context然后执行一个应用程序。

### L43-L48：这几行汇编代码特殊处理了哪些寄存器？这些寄存器的的值对于进入用户态有何意义？请分别解释。

- **sstatus **是一个状态寄存器，用于控制和监控 CPU 的状态，包括中断使能、当前特权级别等。在进入用户态之前，需要设置 `sstatus` 寄存器以确保正确的状态和特权级别。
- **sepc **是异常返回地址寄存器，用于存储下一条要执行的用户态指令的地址。当从内核态返回到用户态时，CPU 将从 `sepc` 指定的地址继续执行。
- **sscratch ** 是一个可以在用户态和内核态之间保持值的私有寄存器，通常用于存储临时数据或指针，以便在特权级别之间切换时使用。

### L50-L56：为何跳过了 `x2` 和 `x4`？

 `tp(x4)` 寄存器，除非我们手动出于一些特殊用途使用它，否则一般也不会被用到。

`x2` 已经L13和L16被恢复到sscratch，所以不需要再恢复了。

### L60：该指令之后，`sp` 和 `sscratch` 中的值分别有什么意义？

交换 sscratch 和 sp，现在 sp 重新指向用户栈栈顶，sscratch 也依然保存 进入 Trap 之前的状态并指向内核栈栈顶。

### `__restore`：中发生状态切换在哪一条指令？为何该指令执行之后会进入用户态？

`sret`指令的执行会将处理器的特权级别从内核态切换回用户态，并将程序计数器（PC）设置为之前保存的用户态程序计数器的值，从而让处理器从中断或异常处理返回到用户程序的正确执行点。

### L13：该指令之后，`sp` 和 `sscratch` 中的值分别有什么意义？

这里起到的是交换 sscratch 和 sp 的效果。现在 sp 指向内核栈， sscratch 指向用户栈。

###  从 U 态进入 S 态是哪一条指令发生的？

`ecall`指令

# 荣誉准则

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 **以下各位** 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

   > ChatGPT（简答题中汇编代码）

2. 此外，我也参考了 **以下资料** ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

   > https://learningos.cn/rCore-Tutorial-Guide-2024S/chapter2/4trap-handling.html
   >
   > https://github.com/riscv-non-isa/riscv-asm-manual/blob/master/riscv-asm.md

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。
